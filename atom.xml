<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-04-02T12:10:33.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Oneday</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mongodb安装教程</title>
    <link href="http://yoursite.com/mongodb-install/"/>
    <id>http://yoursite.com/mongodb-install/</id>
    <published>2017-04-02T10:43:40.000Z</published>
    <updated>2017-04-02T12:10:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在入门mongodb，期间踩了不少坑，在这里记录一下。</p>
<h2 id="系统及mongodb版本"><a href="#系统及mongodb版本" class="headerlink" title="系统及mongodb版本"></a>系统及mongodb版本</h2><ol>
<li>系统：OS X</li>
<li>mongodb版本： 3.4 Community Edition</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装方式有两种，一种是直接在官网下载安装包，然后解压，最后还需要设置PATH，比较麻烦，这里推荐的是第二种按照方式：<a href="https://brew.sh/" target="_blank" rel="external">Homebrew</a>，安装成功之后会自动帮我们设置好PATH，非常方便</p>
<p>使用Homebrew安装<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install mongodb</div></pre></td></tr></table></figure></p>
<p>安装完成之后我们需要创建一个提供给mongodb存储数据的文件夹，mongodb默认使用的文件夹是 /data/db，我们先来创建一个：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir -p /data/db</div></pre></td></tr></table></figure></p>
<p>如果你想使用其他路径文件夹来存储数据可以在启动命令的时候加上dbpath来指定所需要使用的目录路径：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongod --dbpath &lt;path to data directory&gt;</div></pre></td></tr></table></figure></p>
<h2 id="启动mongodb服务器"><a href="#启动mongodb服务器" class="headerlink" title="启动mongodb服务器"></a>启动mongodb服务器</h2><p>接下来我们来启动mongodb的服务，在控制台输入<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongod</div></pre></td></tr></table></figure></p>
<p><img src="/mongodb-install/1.png" alt=""><br>yes，启动成功！<br>从控制台上打印出来的日志我们可以看到mongodb默认的端口号是27017，dbpath=/data/db，我们可以注意到日志中有一行这样的warning信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2017-04-02T18:46:54.942+0800 I CONTROL  [initandlisten] ** WARNING: Access control is not enabled for the database.</div></pre></td></tr></table></figure></p>
<blockquote>
<p>直接使用mongod命令启动的是 <strong>没有进行访问控制</strong> 的访问方式，即可以不用登录就能访问所有数据库</p>
</blockquote>
<p>接下来我们使用需要进行访问控制的启动方式，在这之前我们需要先创建一个角色，mongodb提供了mongo来启动mongodb的客户端</p>
<blockquote>
<p><strong>mongod</strong> 是mongodb的服务端启动命令<br><strong>mongo</strong>是mongodb的客户端启动命令</p>
</blockquote>
<h2 id="启动mongodb客户端："><a href="#启动mongodb客户端：" class="headerlink" title="启动mongodb客户端："></a>启动mongodb客户端：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongo</div></pre></td></tr></table></figure>
<p><img src="/mongodb-install/2.png" alt=""><br>在这我们可以输入mongodb的命令来操作数据库，ok，我们现在来创建一个角色：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">use admin // 使用admin数据库</div><div class="line">db.createUser(</div><div class="line">  &#123;</div><div class="line">    user: &quot;myUserAdmin&quot;,</div><div class="line">    pwd: &quot;abc123&quot;,</div><div class="line">    roles: [ &#123; role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; &#125; ]</div><div class="line">  &#125;</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>创建成功，关闭mongodb服务器和客户端，用访问控制的方式启动服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mongod --auth // 以访问控制的方式启动服务器</div><div class="line">mongo // 启动客户端</div></pre></td></tr></table></figure></p>
<p>在客户端进行登录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">use admin // 使用admin数据库</div><div class="line">db.auth(&quot;myUserAdmin&quot;, &quot;abc123&quot;)</div></pre></td></tr></table></figure></p>
<h2 id="在NodeJs使用mongodb"><a href="#在NodeJs使用mongodb" class="headerlink" title="在NodeJs使用mongodb"></a>在NodeJs使用mongodb</h2><p>首先我们需要在NodeJs里面安装mongodb的驱动<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install mongodb --save</div></pre></td></tr></table></figure></p>
<p>使用方式很简单，在app.js里面添加以下代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> MongoClient = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).MongoClient</div><div class="line">  , assert = <span class="built_in">require</span>(<span class="string">'assert'</span>);</div><div class="line"></div><div class="line"><span class="comment">// Connection URL</span></div><div class="line"><span class="keyword">const</span> url = <span class="string">'mongodb://myUserAdmin:abc123@127.0.0.1:27017/admin'</span>;</div><div class="line"></div><div class="line"><span class="comment">// Use connect method to connect to the server</span></div><div class="line">MongoClient.connect(url, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</div><div class="line">  assert.equal(<span class="literal">null</span>, err);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Connected successfully to server"</span>);</div><div class="line">  db.close();</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// Connected successfully to server</span></div></pre></td></tr></table></figure></p>
<p>ok，接下来就是看文档的事情了~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在入门mongodb，期间踩了不少坑，在这里记录一下。&lt;/p&gt;
&lt;h2 id=&quot;系统及mongodb版本&quot;&gt;&lt;a href=&quot;#系统及mongodb版本&quot; class=&quot;headerlink&quot; title=&quot;系统及mongodb版本&quot;&gt;&lt;/a&gt;系统及mongodb版本&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Js Date对象</title>
    <link href="http://yoursite.com/date/"/>
    <id>http://yoursite.com/date/</id>
    <published>2017-03-25T15:28:29.000Z</published>
    <updated>2017-03-25T16:17:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>Date对象有三个比较常用的构造方法,分别是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span>()</div><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(milliseconds)</div><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(datestring)</div></pre></td></tr></table></figure></p>
<p>以上这些构造方法基本能够满足日常的开发工作，但是如果要编写日期类的控件的话下面的方法能够提供更强大的帮助:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(year, month[, date[, hours[, minutes[, seconds[, milliseconds]]]]])</div></pre></td></tr></table></figure></p>
<p>以下是对这7个参数的描述：</p>
<ul>
<li>year - 年份</li>
<li>month - 月份, 计数从0开始，0代表1月，11代表12月</li>
<li>date - 日期,代表当月的第几天</li>
<li>hours - 小时，代表当天的第几个小时，取值范围：整数</li>
<li>minutes - 分钟，代表指定hours的第几分钟，取值范围：整数</li>
<li>seconds - 秒，代表指定minutes的第几秒，取值范围：整数</li>
<li>milliseconds - 毫秒，代表指定seconds的第几毫秒，取值范围：整数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2017</span>, <span class="number">2</span>) == <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2017-03-01 00:00:00'</span>) <span class="comment">// Wed Mar 01 2017 00:00:00 GMT+0800 (CST) 2017年3月1日</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2017</span>, <span class="number">2</span>, <span class="number">1</span>) === <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2017-03-01 00:00:00'</span>) <span class="comment">// Wed Mar 01 2017 00:00:00 GMT+0800 (CST) 2017年3月1日</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2017</span>, <span class="number">2</span>, <span class="number">2</span>) === <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2017-03-02 00:00:00'</span>) <span class="comment">// Wed Mar 02 2017 00:00:00 GMT+0800 (CST) 2017年3月2日</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2017</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">9</span>) === <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2017-03-02 09:00:00'</span>) <span class="comment">// Wed Mar 02 2017 09:00:00 GMT+0800 (CST) 2017年3月2日09点</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2017</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">8</span>) === <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2017-03-02 09:08:00'</span>) <span class="comment">// Wed Mar 02 2017 09:08:00 GMT+0800 (CST) 2017年3月2日09点08分</span></div><div class="line">...</div></pre></td></tr></table></figure>
<p>ok，我们都知道1个小时只有60分钟，如果minutes取值大于等于60或者小于0怎办？这种情况下Date构造方法会自动进行转换，例如minute=61，则hours加1；如果小于0，则hours减1，其他入参如month，year以此类推<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2017</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">68</span>) <span class="comment">// Thu Mar 02 2017 10:08:00 GMT+0800 (CST)</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2017</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">128</span>) <span class="comment">// Thu Mar 02 2017 11:08:00 GMT+0800 (CST)</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2017</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">-1</span>) <span class="comment">// Thu Mar 02 2017 08:59:00 GMT+0800 (CST)</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2017</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">-61</span>) <span class="comment">// Thu Mar 02 2017 07:59:00 GMT+0800 (CST)</span></div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>好了，知道了基本的用法，接下来我们用这个构造方法计算指定月份的每一天的日期吧<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> daysOfMonth = [];</div><div class="line"><span class="keyword">const</span> fullYear = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</div><div class="line"><span class="keyword">const</span> month = <span class="keyword">new</span> <span class="built_in">Date</span>().getMonth() + <span class="number">1</span>;</div><div class="line"><span class="keyword">const</span> lastDayOfMonth = <span class="keyword">new</span> <span class="built_in">Date</span>(fullYear, month, <span class="number">0</span>).getDate();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= lastDayOfMonth; i++) &#123;</div><div class="line">  <span class="built_in">console</span>.log(fullYear + <span class="string">'-'</span> + month + <span class="string">'-'</span> + i);</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 输出</span></div><div class="line"><span class="comment">// "2017-3-1" "2017-3-2" "2017-3-3" "2017-3-4" "2017-3-5" "2017-3-6" "2017-3-7" "2017-3-8" "2017-3-9" "2017-3-10" "2017-3-11" "2017-3-12" "2017-3-13" "2017-3-14" "2017-3-15" "2017-3-16" "2017-3-17" "2017-3-18" "2017-3-19" "2017-3-20" "2017-3-21" "2017-3-22" "2017-3-23" "2017-3-24" "2017-3-25" "2017-3-26" "2017-3-27" "2017-3-28" "2017-3-29" "2017-3-30" "2017-3-31"</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Date对象有三个比较常用的构造方法,分别是：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;l
    
    </summary>
    
    
      <category term="note" scheme="http://yoursite.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>co源码笔记</title>
    <link href="http://yoursite.com/co/"/>
    <id>http://yoursite.com/co/</id>
    <published>2016-10-23T05:28:01.000Z</published>
    <updated>2016-11-04T15:17:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>这段时间在看Koa的源码，发现Koa的处理异步回调函数是基于co框架上面的，于是想进一步深究这个co到底做了什么黑魔法<br><a id="more"></a></p>
<h2 id="co的github地址："><a href="#co的github地址：" class="headerlink" title="co的github地址："></a>co的github地址：</h2><p><a href="https://github.com/tj/co" target="_blank" rel="external">https://github.com/tj/co</a><br>从文档的API可以看出，co支持promise，thunks，array，object，generator这几大类型</p>
<h2 id="co的本质"><a href="#co的本质" class="headerlink" title="co的本质"></a>co的本质</h2><p>co一旦开始执行就会像永动机一样不断执行下去，直到遇到return才会停止，现在问题来了，为什么会co可以不断执行下去？如何处理异步回调函数？</p>
<ol>
<li><p>为什么co可以不断执行下去？<br>这主要是利用generator的特性，co接受一个generator作为入参，co会不断执行generator里面的yield语句，直到遇到return才停止</p>
</li>
<li><p>如何处理异步回调函数？<br>这主要是利用Promise的特性，yield后面的语句本质上是Promise对象的，咦，不对啊，yield后面不是可以支持Promise,thunks,array,object,generator吗，怎么现在说是Promise对象的呢？别急，下面会解释这个问题</p>
</li>
</ol>
<p><strong>co返回Promise对象，之后可以用then进行接收；co是利用generator和Promise特性进行处理，要想真正理解co的原理，就要先好好理解generator和Promise了~</strong></p>
<h2 id="细读源码"><a href="#细读源码" class="headerlink" title="细读源码"></a>细读源码</h2><p>代码不多，仅仅两百多行，下面来探究其中的奥妙，我把代码连同注释也一起复制过来，中文注释是我在读的过程中加上的笔记，方便日后翻看</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * slice() reference.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Expose `co`.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = co[<span class="string">'default'</span>] = co.co = co;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Wrap the given generator `fn` into a</div><div class="line"> * function that returns a promise.</div><div class="line"> * This is a separate function so that</div><div class="line"> * every `co()` call doesn't create a new,</div><div class="line"> * unnecessary closure.</div><div class="line"> *</div><div class="line"> * @param &#123;GeneratorFunction&#125; fn</div><div class="line"> * @return &#123;Function&#125;</div><div class="line"> * @api public</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * co.wrap仅仅是对co的一层封装，方便把代码包裹起来，多处复用，最终调用的还是co函数</div><div class="line"> */</div><div class="line">co.wrap = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</div><div class="line">  createPromise.__generatorFunction__ = fn;</div><div class="line">  <span class="keyword">return</span> createPromise;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createPromise</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> co.call(<span class="keyword">this</span>, fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>));</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Execute the generator function or a generator</div><div class="line"> * and return a promise.</div><div class="line"> *</div><div class="line"> * @param &#123;Function&#125; fn</div><div class="line"> * @return &#123;Promise&#125;</div><div class="line"> * @api public</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="comment">// co实际上是返回一个Promise对象，并等待这个对象的处理结果</span></div><div class="line"><span class="comment">// 即resolve和reject</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">var</span> args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</div><div class="line"></div><div class="line">  <span class="comment">// we wrap everything in a promise to avoid promise chaining,</span></div><div class="line">  <span class="comment">// which leads to memory leak errors.</span></div><div class="line">  <span class="comment">// see https://github.com/tj/co/issues/180</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="comment">// 开始调用generator，生成对应的实例，等待yield的指令执行具体方法</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">'function'</span>) gen = gen.apply(ctx, args);</div><div class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.next !== <span class="string">'function'</span>) <span class="keyword">return</span> resolve(gen);</div><div class="line"></div><div class="line">    <span class="comment">// generatior开始执行，直到遇到return才会停止</span></div><div class="line">    onFulfilled();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * @param &#123;Mixed&#125; res</div><div class="line">     * @return &#123;Promise&#125;</div><div class="line">     * @api private</div><div class="line">     */</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> ret;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// res是上一个yield指令执行的实际结果，这里把res结果赋值给上一个yield语句，</span></div><div class="line">        <span class="comment">// 作为上一个yield语句的执行结果</span></div><div class="line">        <span class="comment">// 这里又开始执行下一条yield语句，并把结果&#123;"done":"true/false", "value": "res"&#125;</span></div><div class="line">        <span class="comment">// 传给next函数进行结果分析 </span></div><div class="line">        ret = gen.next(res);</div><div class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">        <span class="keyword">return</span> reject(e);</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 开始分析yield结果</span></div><div class="line">      next(ret);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * @param &#123;Error&#125; err</div><div class="line">     * @return &#123;Promise&#125;</div><div class="line">     * @api private</div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> ret;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        ret = gen.throw(err);</div><div class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">        <span class="keyword">return</span> reject(e);</div><div class="line">      &#125;</div><div class="line">      next(ret);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Get the next value in the generator,</div><div class="line">     * return a promise.</div><div class="line">     *</div><div class="line">     * @param &#123;Object&#125; ret</div><div class="line">     * @return &#123;Promise&#125;</div><div class="line">     * @api private</div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="comment">// 这个方法主要对yield语句的结果&#123;"done":"true/false", "value": "res"&#125;进行分析</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">ret</span>) </span>&#123;</div><div class="line">      <span class="comment">// 如果done是true，则表示generator运行结束,并将ret.value作为co</span></div><div class="line">      <span class="comment">// （即Promise对象的处理结果，注意用then或catch接收此处理结果）</span></div><div class="line">      <span class="keyword">if</span> (ret.done) <span class="keyword">return</span> resolve(ret.value);</div><div class="line">      <span class="comment">// 如果done是false，则表示generator还没运行结束，并将ret.value</span></div><div class="line">      <span class="comment">// 转换为Promise并生成promise对象，将处理结果抛给then处理</span></div><div class="line">      <span class="comment">// 即处理结果是onFulfilled和onRejected的入参，继续执行这两个方法</span></div><div class="line">      <span class="comment">// 达到一种永动机的状态</span></div><div class="line">      <span class="keyword">var</span> value = toPromise.call(ctx, ret.value);</div><div class="line">      <span class="keyword">if</span> (value &amp;&amp; isPromise(value)) <span class="keyword">return</span> value.then(onFulfilled, onRejected);</div><div class="line">      <span class="keyword">return</span> onRejected(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'You may only yield a function, promise, generator, array, or object, '</span></div><div class="line">        + <span class="string">'but the following object was passed: "'</span> + <span class="built_in">String</span>(ret.value) + <span class="string">'"'</span>));</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>即在co里面的代码，如果是yield语句则会等待该语句执行完毕才会继续下一条yield语句，如果是return语句则不管return后面的是什么类型的代码，无论是普通function也好，promise也好，array也好都会作为结果原封不动作为结果返回</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这段时间在看Koa的源码，发现Koa的处理异步回调函数是基于co框架上面的，于是想进一步深究这个co到底做了什么黑魔法&lt;br&gt;
    
    </summary>
    
    
      <category term="note" scheme="http://yoursite.com/tags/note/"/>
    
  </entry>
  
</feed>
