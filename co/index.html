<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> co源码笔记 · Hexo</title><meta name="description" content="co源码笔记 - Oneday"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hexo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">co源码笔记</h1><div class="post-info">Oct 23, 2016</div><div class="post-content"><p>这段时间在看Koa的源码，发现Koa的处理异步回调函数是基于co框架上面的，于是想进一步深究这个co到底做了什么黑魔法<br><a id="more"></a></p>
<h2 id="co的github地址："><a href="#co的github地址：" class="headerlink" title="co的github地址："></a>co的github地址：</h2><p><a href="https://github.com/tj/co" target="_blank" rel="external">https://github.com/tj/co</a><br>从文档的API可以看出，co支持promise，thunks，array，object，generator这几大类型</p>
<h2 id="co的本质"><a href="#co的本质" class="headerlink" title="co的本质"></a>co的本质</h2><p>co一旦开始执行就会像永动机一样不断执行下去，直到遇到return才会停止，现在问题来了，为什么会co可以不断执行下去？如何处理异步回调函数？</p>
<ol>
<li><p>为什么co可以不断执行下去？<br>这主要是利用generator的特性，co接受一个generator作为入参，co会不断执行generator里面的yield语句，直到遇到return才停止</p>
</li>
<li><p>如何处理异步回调函数？<br>这主要是利用Promise的特性，yield后面的语句本质上是Promise对象的，咦，不对啊，yield后面不是可以支持Promise,thunks,array,object,generator吗，怎么现在说是Promise对象的呢？别急，下面会解释这个问题</p>
</li>
</ol>
<p><strong>co返回Promise对象，之后可以用then进行接收；co是利用generator和Promise特性进行处理，要想真正理解co的原理，就要先好好理解generator和Promise了~</strong></p>
<h2 id="细读源码"><a href="#细读源码" class="headerlink" title="细读源码"></a>细读源码</h2><p>代码不多，仅仅两百多行，下面来探究其中的奥妙，我把代码连同注释也一起复制过来，中文注释是我在读的过程中加上的笔记，方便日后翻看</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * slice() reference.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Expose `co`.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = co[<span class="string">'default'</span>] = co.co = co;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Wrap the given generator `fn` into a</div><div class="line"> * function that returns a promise.</div><div class="line"> * This is a separate function so that</div><div class="line"> * every `co()` call doesn't create a new,</div><div class="line"> * unnecessary closure.</div><div class="line"> *</div><div class="line"> * @param &#123;GeneratorFunction&#125; fn</div><div class="line"> * @return &#123;Function&#125;</div><div class="line"> * @api public</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * co.wrap仅仅是对co的一层封装，方便把代码包裹起来，多处复用，最终调用的还是co函数</div><div class="line"> */</div><div class="line">co.wrap = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</div><div class="line">  createPromise.__generatorFunction__ = fn;</div><div class="line">  <span class="keyword">return</span> createPromise;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createPromise</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> co.call(<span class="keyword">this</span>, fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>));</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Execute the generator function or a generator</div><div class="line"> * and return a promise.</div><div class="line"> *</div><div class="line"> * @param &#123;Function&#125; fn</div><div class="line"> * @return &#123;Promise&#125;</div><div class="line"> * @api public</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="comment">// co实际上是返回一个Promise对象，并等待这个对象的处理结果</span></div><div class="line"><span class="comment">// 即resolve和reject</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">var</span> args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</div><div class="line"></div><div class="line">  <span class="comment">// we wrap everything in a promise to avoid promise chaining,</span></div><div class="line">  <span class="comment">// which leads to memory leak errors.</span></div><div class="line">  <span class="comment">// see https://github.com/tj/co/issues/180</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="comment">// 开始调用generator，生成对应的实例，等待yield的指令执行具体方法</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">'function'</span>) gen = gen.apply(ctx, args);</div><div class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.next !== <span class="string">'function'</span>) <span class="keyword">return</span> resolve(gen);</div><div class="line"></div><div class="line">    <span class="comment">// generatior开始执行，直到遇到return才会停止</span></div><div class="line">    onFulfilled();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * @param &#123;Mixed&#125; res</div><div class="line">     * @return &#123;Promise&#125;</div><div class="line">     * @api private</div><div class="line">     */</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> ret;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// res是上一个yield指令执行的实际结果，这里把res结果赋值给上一个yield语句，</span></div><div class="line">        <span class="comment">// 作为上一个yield语句的执行结果</span></div><div class="line">        <span class="comment">// 这里又开始执行下一条yield语句，并把结果&#123;"done":"true/false", "value": "res"&#125;</span></div><div class="line">        <span class="comment">// 传给next函数进行结果分析 </span></div><div class="line">        ret = gen.next(res);</div><div class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">        <span class="keyword">return</span> reject(e);</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 开始分析yield结果</span></div><div class="line">      next(ret);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * @param &#123;Error&#125; err</div><div class="line">     * @return &#123;Promise&#125;</div><div class="line">     * @api private</div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> ret;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        ret = gen.throw(err);</div><div class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">        <span class="keyword">return</span> reject(e);</div><div class="line">      &#125;</div><div class="line">      next(ret);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Get the next value in the generator,</div><div class="line">     * return a promise.</div><div class="line">     *</div><div class="line">     * @param &#123;Object&#125; ret</div><div class="line">     * @return &#123;Promise&#125;</div><div class="line">     * @api private</div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="comment">// 这个方法主要对yield语句的结果&#123;"done":"true/false", "value": "res"&#125;进行分析</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">ret</span>) </span>&#123;</div><div class="line">      <span class="comment">// 如果done是true，则表示generator运行结束,并将ret.value作为co</span></div><div class="line">      <span class="comment">// （即Promise对象的处理结果，注意用then或catch接收此处理结果）</span></div><div class="line">      <span class="keyword">if</span> (ret.done) <span class="keyword">return</span> resolve(ret.value);</div><div class="line">      <span class="comment">// 如果done是false，则表示generator还没运行结束，并将ret.value</span></div><div class="line">      <span class="comment">// 转换为Promise并生成promise对象，将处理结果抛给then处理</span></div><div class="line">      <span class="comment">// 即处理结果是onFulfilled和onRejected的入参，继续执行这两个方法</span></div><div class="line">      <span class="comment">// 达到一种永动机的状态</span></div><div class="line">      <span class="keyword">var</span> value = toPromise.call(ctx, ret.value);</div><div class="line">      <span class="keyword">if</span> (value &amp;&amp; isPromise(value)) <span class="keyword">return</span> value.then(onFulfilled, onRejected);</div><div class="line">      <span class="keyword">return</span> onRejected(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'You may only yield a function, promise, generator, array, or object, '</span></div><div class="line">        + <span class="string">'but the following object was passed: "'</span> + <span class="built_in">String</span>(ret.value) + <span class="string">'"'</span>));</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>即在co里面的代码，如果是yield语句则会等待该语句执行完毕才会继续下一条yield语句，如果是return语句则不管return后面的是什么类型的代码，无论是普通function也好，promise也好，array也好都会作为结果原封不动作为结果返回</strong></p>
</div></article></div></section><footer><div class="paginator"><a href="/date/" class="prev">PREV</a></div><div data-thread-key="co/" data-title="co源码笔记" data-url="http://yoursite.com/co/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"seansun"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">Oneday</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>